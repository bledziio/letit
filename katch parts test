_G.autoQuest = false
local task_defer = task.defer

local questPokemonList = {
    {"Bouldrunt", "Bouldram"},
    {"Voidpup", "Voidstalker"},
    {"Frostkit", "Frostfang"},
    {"Wuarrykit", "Quarryclaw"},
    {"Driplet", "Hydromusk"},
    {"Terrazee", "Terrakong"},
    {"Gemara"}
}

local function invokeService(servicePath, args)
    game:GetService("ReplicatedStorage")
        :WaitForChild("Packages")
        :WaitForChild("_Index")
        :WaitForChild("sleitnick_knit@1.7.0")
        :WaitForChild("knit")
        :WaitForChild("Services")
        :WaitForChild("PlayerService")
        :WaitForChild("RF")
        :WaitForChild(servicePath)
        :InvokeServer(unpack(args))
end

local function tameCreature(creatureName)
    print("Starting tameCreature for: " .. creatureName)
    invokeService("RequestStartTameCreature", {creatureName, "#2"})
    print("Requested Start Tame Creature")
    invokeService("RequestEndTameCreature", {creatureName})
    print("Requested End Tame Creature")
end

local function checkQuestAndCapture()
    print("Starting checkQuestAndCapture")
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    local stopDistance = 5 -- Adjust this distance to stop before the object
    
    -- Player position at world 8 center
    humanoidRootPart.CFrame = CFrame.new(1853.481689453125, 0.6721579432487488, -1133.0943603515625)
    print("Teleported to world 8 center")
    task.wait(1) -- Wait for teleport to complete

    while _G.autoQuest do
        print("AutoQuest is running")
        local questText = game:GetService("Players").LocalPlayer.PlayerGui.QuestTrackerUI.Frame.textFrame.objective.title1.Text
        print("Quest Text: " .. questText)
        local targetPokemon = nil
        local fallbackPokemon = nil

        -- Find target and fallback Pokémon from the quest text
        for _, group in ipairs(questPokemonList) do
            if questText:find(group[1]) then
                targetPokemon = group[1]
                fallbackPokemon = group[2] or group[1]
                print("Target Pokemon: " .. targetPokemon .. " | Fallback Pokemon: " .. fallbackPokemon)
                break
            end
        end

        if targetPokemon then
            local foundCreature = false
            local attempts = 0

            while not foundCreature and attempts < 10 do
                print("Search attempt: " .. attempts)
                attempts = attempts + 1

                for _, creature in ipairs(workspace.Creatures:GetChildren()) do
                    local playerNameText = creature:FindFirstChild("RootPart")
                        and creature.RootPart:FindFirstChild("TitanNameplate")
                        and creature.RootPart.TitanNameplate:FindFirstChild("InfoFrame")
                        and creature.RootPart.TitanNameplate.InfoFrame:FindFirstChild("PlayerName")
                        and creature.RootPart.TitanNameplate.InfoFrame.PlayerName.Text

                    if playerNameText and playerNameText:find(targetPokemon) then
                        print("Found target Pokemon: " .. creature.Name)
                        -- Calculate the position to stop before the object
                        local targetPosition = creature:GetPrimaryPartCFrame().Position
                        local direction = (targetPosition - humanoidRootPart.Position).unit
                        local stopPosition = targetPosition - direction * stopDistance

                        -- Move character to the stop position facing the object
                        humanoid:MoveTo(stopPosition)
                        humanoid.MoveToFinished:Wait()  -- Wait until movement is finished
                        print("Moved to target Pokemon")

                        -- Execute the taming code
                        tameCreature(creature.Name)
                        print("Tamed target Pokemon")
                        foundCreature = true
                        task.wait(1)

                        -- Check if quest is completed
                        local captures = game:GetService("Players").LocalPlayer.leaderstats.Captures.Value
                        print("Current Captures: " .. captures)

                        -- Request release of the captured creature
                        local releaseArgs = { [1] = "@" .. tostring(captures) }
                        invokeService("CreatureService/RF/RequestReleasePet", releaseArgs)
                        print("Released Pokemon with capture value: " .. tostring(captures))

                        break
                    end
                end

                if not foundCreature and attempts == 5 then
                    -- Switch to fallback Pokémon if the target Pokémon is not found after 5 attempts
                    targetPokemon = fallbackPokemon
                    print("Switching to fallback Pokemon: " .. fallbackPokemon)
                end
            end

            -- Request to complete the quest
            local completeQuestArgs = { [1] = "#8" }
            invokeService("PlayerService/RF/RequestCompleteNpcQuest", completeQuestArgs)
            print("Requested quest completion")

            -- Request a new quest
            local startQuestArgs = { [1] = "#8" }
            invokeService("PlayerService/RF/RequestStartNpcQuest", startQuestArgs)
            print("Requested new quest")
        else
            print("No matching Pokemon found in quest text")
        end
        
        task.wait(1)
    end
end

local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/miroeramaa/TurtleLib/main/TurtleUiLib.lua"))()
local window = library:Window("quest")

window:Toggle("quest capture", false, function(bool)
    _G.autoQuest = bool
    if _G.autoQuest then
        task_defer(checkQuestAndCapture)
    end
end)

library:Keybind("P")

print("Setup complete")
